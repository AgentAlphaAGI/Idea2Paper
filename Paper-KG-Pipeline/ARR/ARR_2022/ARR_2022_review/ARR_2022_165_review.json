[{"rid": "5a2c468d42a1d327d15cde4be8dfa3b3f2024ba2dd4889191b47d642f341cc72dd9eaff4f056d7f9f33a4c085bca790e7fe3709f69568617ea9ab97b3d202a52", "reviewer": null, "report": {"paper_summary": "This paper proposes a “plug and play” method for controlled text generation using language models, i.e., it does not require finetuning of the language model used for generation. Their algorithm uses MCTS, where the policy balances sequence likelihood with the score from a discriminator that determines the presence of certain textual attributes. This balance encourages generation to meet certain constraints while maintaining quality. They provide empirical evidence of the effectiveness of the algorithm. ", "summary_of_strengths": "The paper offers an intuitive extension of MCTS for controlled generation that doesn’t require fine-tuning of a language model. The method has the potential to be widely applicable. The experiments are very comprehensive, exploring multiple baselines, datasets, and parameter settings. ", "summary_of_weaknesses": "- The MCTS algorithm itself in the context of text generation is not explained very well, which makes it hard to understand the proposed algorithm - The need for a discriminator for any possible constraint can be quite limiting to the applicability of the algorithm - There lacks a formal runtime analysis. Speed during decoding is often quite important and it's unclear what the extent of the computational drawbacks of this algorithm are - There have been a number of recent works also using MCTS for language generation. I am not very familiar with these works so it is hard for me to tell how novel this paper is in context ", "comments,_suggestions_and_typos": "- I don’t quite see where p(x|c) fits into equation 1. Is it just s_i? This could be made more clear - In terms of plug and play controlled generation methods that do not require fine-tuning of an LM, a citation is missing for Pascual et. al. 2021. Schick et. al 2021 also use a discriminator at each time step to control generation for certain attributes - Line 467: the standard definition of perplexity used in language modeling divides by the number of tokens, and so is not dependent on length - Line 228: token -> tokens "}, "scores": {"overall": "3.5 ", "best_paper": "No", "datasets": "1 = No usable datasets submitted.", "software": "1 = No usable software released."}, "meta": {"license": "Copyright © 2021 administered by the Association for Computational Linguistics (ACL)\n                                on behalf of ACL content contributors: None, and other contributors who wish to remain anonymous.\n                                Content is made available under a Creative Commons Attribution 4.0 International Public License.", "author_identity_guess": "1 = I do not have even an educated guess about author identity.", "confidence": "4 = Quite sure. I tried to check the important points carefully. It's unlikely, though conceivable, that I missed something that should affect my ratings.", "sentences": {"paper_summary": [[0, 179], [179, 348], [348, 438], [438, 509]], "summary_of_strengths": [[0, 128], [128, 182], [182, 286]], "summary_of_weaknesses": [[0, 147], [147, 266], [266, 307], [307, 440], [440, 524], [524, 628]], "comments,_suggestions_and_typos": [[0, 55], [55, 71], [71, 101], [101, 239], [239, 249], [249, 260], [260, 356], [356, 499], [499, 527]]}}}, {"rid": "5385e108c4289cb35d6f7b461c2bcaeebbee34cca1d25e188f47b58f7879ab8a08786fd6c10f4d8ff2bf799a34aa55688a1d2e6b2dc16ea4f97e52d290ac21bb", "reviewer": "Nan Jiang", "report": {"paper_summary": "The authors propose to use Monte Carlo Tree Search to generate sentences that satisfy the constraints. The authors conduct rigorous experiment analysis to show the advantage of the method ", "summary_of_strengths": "The paper is well written and easy to follow. The figures present the idea clearly. There are various experiments to support the proposed method. ", "summary_of_weaknesses": "What specific problem that previous approaches cannot solve but this paper can resolve? Or in terms of what aspect, discriminator-guided decoding can do better (not just score)? For example, every constraint is modeled as one discriminator, will it mean the model is better modularized? ", "comments,_suggestions_and_typos": "- could you give a detailed example of what \"constraint\" is used in this paper? It is not clear how multiple discriminators can enforce constraints simultaneously.\n- MCTS is mainly used in RL since the state transition and reward function are probability distributions. It is unclear why you need MCTS to do a search, why not just depth-first search, best-first search, A* search, or any heuristic search? Could you highlight the necessary steps that can achieve discriminator-guided decoding?\n- Do you assume you can naturally have every constraint as well as the corresponding discriminator?\n- you can put all the HTTPS links as footnotes.\n- Line 513 \"Go of RAM\" ->  \"GB of RAM\" "}, "scores": {"overall": "3.5 ", "best_paper": "No", "datasets": "3 = Potentially useful: Someone might find the new datasets useful for their work.", "software": "4 = Useful: I would recommend the new software to other researchers or developers for their ongoing work."}, "meta": {"license": "Copyright © 2021 administered by the Association for Computational Linguistics (ACL)\n                                on behalf of ACL content contributors: Nan Jiang, and other contributors who wish to remain anonymous.\n                                Content is made available under a Creative Commons Attribution 4.0 International Public License.", "author_identity_guess": "4 = From an allowed pre-existing preprint or workshop paper, I know/can guess at least one author's name.", "confidence": "3 =  Pretty sure, but there's a chance I missed something. Although I have a good feel for this area in general, I did not carefully check the paper's details, e.g., the math or experimental design.", "sentences": {"paper_summary": [[0, 103], [103, 188]], "summary_of_strengths": [[0, 46], [46, 84], [84, 146]], "summary_of_weaknesses": [[0, 88], [88, 178], [178, 287]], "comments,_suggestions_and_typos": [[0, 80], [80, 164], [164, 270], [270, 406], [406, 494], [494, 594], [594, 642], [642, 681]]}}}]